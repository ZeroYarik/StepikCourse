# lst = ["+7", "+6", "+5", "+4"]
# a = dict.fromkeys(lst)
# print(a)
#
# a = dict.fromkeys(lst, " код страны")
# print(a)
# a.clear()
# print(a)
#
# d = {True: 1, False: "Ложь", "list": [1,2,3], 5: 5}
# print(d)
# d2 = d.copy()
# print(d2)
# d2["list"] = [5,6,7]
# print(d2)
# print(id(d))
# print(id(d2))
#
# print(d.get("list")) # Если ключа нет то возвращает значение None в отличии от d["list"] который вернет ошибку.
# print(d2.get(3, False))
#
# print(d.setdefault("list"))
# print(d.setdefault("3"))
# print(d)
# del d["3"]
# print(d)
# print(d.setdefault(3, "three"))
# print(d)
# d.pop(3)
# print(d)
# print(d.pop('abc', False)) # удаление по ключу
# print(d.popitem()) # удаляет последнюю запись так как с python 3.7 словарь это упорядоченная коллекция
# print(d.keys()) # список ключей
# print(d.values()) # список значений
# print(d.items()) # возвращает кортеж из ключа-значений

# d = dict(one = 1, two = 2, three = "3", four = "4")
# d2 = {2: "неудовлетворительно", 3: "удовлетворительно", 'four': "хорошо", 5: "отлично"}
#
# # d.update(d2) # обновляет один словарь содержимым дрругого
# # print(d)
# # d3 = {**d, **d2} # объединение двух словарей
# # print(d3)
# d3 = d | d2 # более новое объединение двух словарей
# print(d3)


# Вводится строка из русских букв и символов пробела. Необходимо ее закодировать азбукой Морзе, где каждой букве
# ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять пробел
# (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки).
# Коды азбуки Морзе приведены ниже для русского алфавита и символа пробела:
# Результат кодирования вывести в виде строки.


# name = 'ЯРОСЛАВ ГЛУЩЕНКО'
# morze_code = {'А': '.-', 'Б': '-...', 'В': '.--', 'Г': '--.', 'Д': '-..', 'Е': '.', 'Ё': '.', 'Ж': '...-',
#               'З': '--..', 'И': '..','Й': '.---', 'К': '-.-', 'Л': '.-..', 'М': '--', 'Н': '-.', 'О': '---',
#               'П': '.--.', 'Р': '.-.', 'С': '...', 'Т': '-', 'У': '..-', 'Ф': '..-.', 'Х': '....', 'Ц': '-.-.',
#               'Ч': '---.', 'Ш': '----', 'Щ': '--.-', 'Ъ': '--.--', 'Ы': '-.--', 'Ь': '-..-', 'Э': '..-..',
#               'Ю': '..--', 'Я': '.-.-', ' ': '-...-'}
#
#
#
# for x in name:
#     if x in morze_code.keys():
#         new_name = {}
#         new_name = morze_code[x]
#
#         print(new_name, end=' ')

# Имеется закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом.
# Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия.
# Полученное сообщение (строку) вывести на экран.


# morze_code = {'А': '.-', 'Б': '-...', 'В': '.--', 'Г': '--.', 'Д': '-..', 'Е': '.',  'Ж': '...-',
#               'З': '--..', 'И': '..','Й': '.---', 'К': '-.-', 'Л': '.-..', 'М': '--', 'Н': '-.', 'О': '---',
#               'П': '.--.', 'Р': '.-.', 'С': '...', 'Т': '-', 'У': '..-', 'Ф': '..-.', 'Х': '....', 'Ц': '-.-.',
#               'Ч': '---.', 'Ш': '----', 'Щ': '--.-', 'Ъ': '--.--', 'Ы': '-.--', 'Ь': '-..-', 'Э': '..-..',
#               'Ю': '..--', 'Я': '.-.-', ' ': '-...-'}
#
# string = input().split()
#
# for i in string:
#     for k, v in morze_code.items():
#         if i == v:
#             print(k.lower(), end='')

# Вводится список целых чисел в одну строчку через пробел.
# С помощью словаря выделите только уникальные (не повторяющиеся) введенные значения и, затем, сформируйте список
# из уникальных чисел. Выведите его на экран в виде набора чисел, записанных через пробел.
# P. S. Такая задача, обычно решается через множества, но мы их еще не проходили, поэтому воспользуемся словарем.

# nums = list(map(int, input().split()))
# d = {}
# for i in nums:
#     if i not in d:
#         d[i] = []
#
# print(*d.keys())

# Вводятся данные в формате:
# <день рождения 1> имя_1
# <день рождения 2> имя_2
# <день рождения N> имя_N
# Дни рождений и имена могут повторяться. На их основе сформировать словарь и вывести его в формате (см. пример ниже):
# день рождения 1: имя1, ..., имяN1
# день рождения 2: имя1, ..., имяN2
# день рождения M: имя1, ..., имяNM
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# days = {3: 'Сергей', 5: 'Николай', 4: 'Елена', 7: 'Владимир', 5: 'Юлия', 4: 'Светлана'}
# import sys
#
# # считывание списка из входного потока
# days = [value.split() for value in list(map(str.strip, sys.stdin.readlines()))]
# brit_day = {}
#
# for key, value in days:           # Перебираю элементы в полученном списке и вывожу по два за итерацию (значение из вложенных списков)
#     if key in brit_day.keys():       # Если ключ уже есть
#         # brit_day[key] = [brit_day[key], value] # Добавляю к тому же ключу еще значения
#         brit_day[key].append(value)  # Добавляю к тому же ключу еще значения
#     else:
#         brit_day[key] = [value]      # Если нет то добавляем ключи и значение в словарь
# for key, value in brit_day.items():  # Прохожу по словарю с помощь  .items() извлекаю ключи и значения
#     print(f"{key}: {', '.join(value)}") # Выв

# Имеется словарь с наименованиями предметов и их весом (в граммах):
# Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг (вводится с клавиатуры).
# Он решил класть в рюкзак предметы в порядке убывания их веса (сначала самые тяжелые, затем, все более легкие) так,
# чтобы их суммарный вес не превысил значения N кг. Все предметы даны в единственном экземпляре.
# Выведите список предметов (в строчку через пробел), которые берет с собой Сергей в порядке убывания их веса.
# P. S. 1 кг = 1000 грамм
# input1 = int(input()) * 1000
# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
#
# result = []
# things2 = {}
# things2.update(things)
# sorted_things = sorted(things2.items(), key=lambda x:x[1], reverse=True)
# converted = dict(sorted_things)
#
# for k, v in converted.items():
#     if input1 >= converted[k]:
#         result.append(k)
#         input1 -= converted[k]
#
# print(*result)


