# def get_v(a, b, c, verbose=True): # """Формальные параметры и фактические параметры. Фактические параметры мы обязаны про
# # писывать при вызове функции. Формальные нет."""
#     if verbose:
#         print(f"a = {a}, b = {b}, c = {c}")
#
#     return a * b * c
#
#
# res = get_v(b=1, c=3, a=2) # именованные аргументы. мы задаем явно имена параметров к которым присваиваем значения.
# # очередность имеет значение.
# print(res)


# def cmp_str(s1, s2, reg=False, trim=True):
#     if reg:
#         s1 = s1.lower()
#         s2 = s2.lower()
#     if trim:
#         s1 = s1.strip()
#         s2 = s2.strip()
#
#     return s1 == s2
#
#
# print(cmp_str("Python ", " PytHon", True))


# def add_value(value, lst=None):
#     if lst == None:
#         lst = []
#     lst.append(value)
#     return lst
#
# l = add_value(1)
# l = add_value(2)
# print(l)


# Объявите функцию с именем get_rect_value, которая принимает два аргумента (два числа) и еще один формальный параметр
# type с начальным значением 0. Если параметр type равен нулю, то функция должна возвращать периметр прямоугольника,
# а иначе - его площадь.
# P. S. Вызывать функцию не нужно, только объявить.
# def get_rect_value(x, y, type=0):
#     if type == 0:
#         return (x + y) * 2
#     else:
#         return x * y
#
#
# res = get_rect_value(5, 10, 1)
# print(res)


# Объявите функцию с именем check_password, которая принимает аргумент - строку (пароль) и имеет один формальный
# параметр chars с начальным значением в виде строки "$%!?@#". Функция должна проверять: есть ли в пароле хотя бы
# один символ из chars и что длина пароля не менее 8 символов. Если проверка проходит,
# то функция возвращает True, иначе - False.
# P. S. Вызывать функцию не нужно, только объявить.
# def check_password(s, chars='$%!?@#'):
#     for i in chars:
#         if i in s and len(s) >= 8:
#             return True
#     else:
#         return False
#
#
# res = check_password("12345678!")
# print(res)

# Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу, используя
# следующий словарь для замены русских букв на соответствующее латинское написание:
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# Функция должна возвращать преобразованную строку. Замены делать без учета регистра
# (исходную строку перевести в нижний регистр - малые буквы).
# У функции также определить формальный параметр sep с начальным значением в виде строки "-".
# Он будет определять символ для замены пробелов в строке.
# После объявления функции прочитайте (с помощью функции input) строку и дважды вызовите функцию
# (с выводом результата ее работы на экран):
# - первый раз только со строкой
# - второй раз со строкой и именованным аргументом sep со значением '+'.

# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# def translit(text, sep = '-'):
#     """  Функция принимает строку на кириллице и разделитель,
#     и преобразовывает ее в латиницу. """
#     sp = [t[el] if el in t else el for el in text]
#     res = sep.join(''.join(sp).split())
#     return res
# text = input().lower()       # Получаем ввыденный текст
# print(translit(text))        # Выводим текст с разделителем по умолчанию
# print(translit(text, '+'))   # Выводим текст с нашим разделителем

# Объявите функцию, которая принимает строку и заключает ее в указанный тег. Тег определяется формальным параметров tag
# с начальным значением в виде строки "h1". Например, мы передаем строку "Hello Python" и заключаем в тег "h1".
# На выходе должны получить строку (без кавычек):
# "<h1>Hello Python</h1>"
# То есть, сначала открывается тег <h1>, а в конце строки - закрывается </h1>. И так для любых указанных тегов.
# После объявления функции прочитайте (с помощью функции input) строку и дважды вызовите функцию
# (с выводом результата ее работы на экран):
# - первый раз только со строкой
# - второй раз со строкой и именованным аргументом tag со значением 'div'.
# def tagger(s, tag: str="<h1>", tag1: str="</h1>"):
#     return tag + text + tag1
#
#
# text = input()
# res = tagger(text)
# res1 = tagger(text, tag="<div>", tag1="</div>")
# print(res)
# print(res1)

#  Функции из предыдущего подвига 5 добавьте еще один формальный параметр up с начальным булевым значением True.
#  Если параметр up равен True, то тег (указанный в формальном параметре tag) следует записывать заглавными буквами,
#  а иначе - малыми.
# После объявления функции прочитайте (с помощью функции input) строку и дважды вызовите функцию
# (с выводом результата ее работы на экран):
# - первый раз со строкой и именованным аргументом tag со значением 'div'
# - второй раз со строкой, именованным аргументом tag со значением 'div' и именованным аргументом up со значением False.
# def tagger(s, tag: str="<h1>", tag1: str="</h1>", up=True):
#     if up:
#         return tag.upper() + text + tag1.upper()
#     else:
#         return tag + text + tag1
#
# text = input()
# res = tagger(text, tag="<div>", tag1="</div>", up=False)
# res1 = tagger(text, tag="<div>", tag1="</div>")
# print(res1)
# print(res)