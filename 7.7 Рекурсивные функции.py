


# def recurdive(value):
#     print(value)
#     if value < 8:
#         recurdive(value+1)
#
#
#
# recurdive(1)

# В РЕКУРСИИ ПОДЗАДАЧА ДОЛЖНА БЫТЬ ПРОЩЕ ЧЕМ ЗАДАЧА
# КРАЙНИЙ СЛУЧАЙ - ТО НА ЧЕМ РЕКУРСИЯ ЗАКАНЧИВАЕТСЯ БЕЗ ВЫЗОВА СЛЕДУЮЩЕЙ ФУНКЦИИ
# РЕКУРРЕНТНЫЙ СЛУЧАЙ - ЛЮБОЙ ДРУГОЙ СЛУЧАЙ РЕКУРСИИ
# ПЕРЕПОЛНЕНИЕ СТЕКА ВЫЗОВОВ ЕСЛИ НЕ КОРРЕКТНО СОСТАВЛЕНА РЕКУРСИЯ
# ПРИ КЖДОМ ВЫЗОВЕ ФУНКЦИИ СВОЕ ПРОСТРАНСТВО ИМЕН
# ГЛУБИНА РЕКУРСИИ - КОЛИЧЕСТВО ВЫЗОВОВ ФУНКЦИИ

# def fact(n):
#     if n <= 0:
#         return 1
#     else:
#         return n * fact(n-1)
#
#
# f = fact(6)
# print(f)

# F = {
#     'C:': {
#         'Python39': ['python.exe', 'python.ini'],
#         'Program Files': {
#             'Java': ['README.txt', 'Welcome.html', 'java.exe'],
#             'MATLAB': ['matlab.bat', 'matlab.exe', 'mcc.bat']
#         },
#         'Windows': {
#             'System32': ['acledit.dll', 'aclui.dll', 'zipfldr.dll']
#         }
#     }
# }
#
#
# def get_files(path, depth=0):
#     for f in path:
#         print(" "*depth, f)
#         if type(path[f]) == dict:
#             get_files(path[f], depth+1)
#         else:
#             print(" "*(depth+1), " ".join(path[f]))
#
#
# get_files(F)

# Вводится целое положительное число N. Необходимо написать рекурсивную функцию с именем get_rec_N, которая отображает
# на экране последовательность целых чисел от 1 до N (включительно). Каждое число выводится с новой строки.
# В качестве параметра функция get_rec_N должна принимать одно числовое значение.
# То есть, иметь только один параметр. Начальный вызов функции будет выглядеть так:
# get_rec_N(N)
# Вызывать функцию не нужно, только объявить.
# N = int(input())
# def get_rec_N(N):
#     if N > 0:
#         get_rec_N(N-1)
#         print(N)
#
#
# x = get_rec_N(N)
# print(x)


# Вводится список целых чисел в одну строчку через пробел.
# Необходимо вычислить сумму этих введенных значений, используя рекурсивную функцию (для перебора элементов списка)
# с именем get_rec_sum. Функция должна возвращать значение суммы. (Выводить на экран она ничего не должна).
# Вызовите эту функцию и выведите вычисленное значение суммы на экран.

# nums = list(map(int, input().split()))
#
# def get_rec_sum(nums):
#     if len(nums) == 0:
#         return 0
#     return nums[0] + get_rec_sum(nums[1:])
#
#
# x = get_rec_sum(nums)
#
# print(x)

# Подвиг 4. Вводится натуральное число N. Необходимо с помощью рекурсивной функции fib_rec(N, f=[])
# (здесь N - общее количество чисел Фибоначчи; f - начальный список этих чисел) сформировать последовательность чисел
# Фибоначчи по правилу: первые два числа равны 1 и 1, а каждое следующе значение равно сумме двух предыдущих.
# Пример такой последовательности для первых 7 чисел: 1, 1, 2, 3, 5, 8, 13, ...
# Функция должна возвращать список сформированной последовательности длиной N.
# Вызывать функцию не нужно, только объявить.

# N = int(input())
# def fib_rec(N, f=[1, 1]):
#     if N > 2:
#         f.append(f[-1] + f[-2])
#         fib_rec(N - 1)
#     return f
# x = fib_rec(N)
# print(x)

# Вводится целое неотрицательное число n. Необходимо с помощью рекурсивной функции fact_rec вычислить факториал числа n.
# Напомню, что факториал числа, равен: n! = 1 * 2 * 3 *...* n. Функция должна возвращать вычисленное значение.
# Вызывать функцию не нужно, только объявить со следующей сигнатурой:
# def fact_rec(n): ...
# n = int(input())
# def fact_rec(n):
#     if n == 0:
#         return 1
#     return n * fact_rec(n-1)
#
# x = fact_rec(n)
# print(x)

#  Имеется следующий многомерный список:
# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
# С помощью рекурсивной функции get_line_list создать на его основе одномерный список из значений элементов списка d.
# Функция должна возвращать новый созданный одномерный список.  (Только возвращать, выводить на экран ничего не нужно.)
# Вызывать функцию не нужно, только объявить со следующей сигнатурой:
# def get_line_list(d,a=[]): ...
# где d - исходный список; a - новый формируемый.
# d = [4, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
#
#
# def get_line_list(d,a=[]):
#     for i in d:
#         if type(i) == list:
#             get_line_list(i)
#         else:
#             a.append(i)
#     return a
#
# x = get_line_list(d)
# print(x)

# n = int(input())
# def get_path(n):
#     if n == 1:
#         return 1
#     if n == 2:
#         return 2
#     return get_path(n-1) + get_path(n-2)
#
# x = get_path(n)
# print(x)

l1 = [1,2,3,4,5,6,7,8,9]
l2 = [1,2,3,4,5,6,7,8]
l5 = 
l3 = sorted(l1 + l2)
l4 = l1.sort()
print(l3)
print(l4)

# Вводится список из целых чисел в одну строчку через пробел. Необходимо выполнить его сортировку по возрастанию с
# помощью алгоритма сортировки слиянием.
# Функция должна возвращать новый отсортированный список.
# Вызовите результирующую функцию сортировки для введенного списка и отобразите результат на экран в виде
# последовательности чисел, записанных через пробел.
# Подсказка. Для разбиения списка и его последующей сборки используйте рекурсивные функции.
# P. S. Теория сортировки в видео предыдущего шага.
#
# nums = list(map(int, input().split()))
# def sort_nums(nums):
#     if len(nums) == 1:
#         return nums
#