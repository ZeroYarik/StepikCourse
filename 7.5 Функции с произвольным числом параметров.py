# m = max(1,2,3,4,5,-6)
# print(m)

# def os_path(*args,sep='\\', **kwargs): #формальные параметры должны идти до соответствующей коллекции.
#
#     path = sep.join(args)
#     return path
#
# p = os_path("F:\~stepik.org\Добрый, добрый Python (Питон)\39\p39. Функции.docx ", sep='/')
# print(p)

# Объявите функцию с именем get_even, которая принимает произвольное количество чисел в качестве аргументов и
# возвращает список, составленный только из четных переданных значений.
# Функцию выполнять не нужно, только определить.

# def get_even(*args: int) -> list:
#     return [i for i in args if i % 2 == 0]

# Объявите функцию с именем get_biggest_city, которой можно передавать произвольное количество названий городов
# через аргументы. Данная функция должна возвращать название города наибольшей длины.
# Если таких городов несколько, то первый найденный (из наибольших). Программу реализовать без использования сортировки.
# Функцию выполнять не нужно, только определить.
# def get_biggest_city(*args:str ):
#     return max(args, key=len)

# Объявите функцию с именем get_data_fig для вычисления периметра произвольного N-угольника.
# На вход этой функции передаются N длин сторон через аргументы.
# Дополнительно могут быть указаны именованные аргументы:
# type - булево значение True/False
# color - целое числовое значение
# closed - булево значение True/False
# width - целое значение
# Функция должна возвращать в виде кортежа периметр многоугольника и указанные значения именованных параметров в
# порядке их перечисления в тексте задания (если они были переданы).
# Если какой-либо параметр отсутствует, его возвращать не нужно (пропустить).
# Функцию выполнять не нужно, только определить.

# def get_data_fig(*args, **kwargs) -> tuple:
#     sq = sum(args)
#     t = (sq, )
#     if "type" in kwargs:
#         typ_e = kwargs["type"]
#         t += (typ_e,)
#     if "color" in kwargs:
#         color = kwargs["color"]
#         t += (color,)
#     if "closed" in kwargs:
#         closet = kwargs["closed"]
#         t += (closet,)
#     if "width" in kwargs:
#         width = kwargs["width"]
#         t += (width,)
#
#     return(t)
#
# res = get_data_fig(4, 4 , 5, color="red")
# print(res)


#  (Для закрепления предыдущего материала). Вводится таблица целых чисел (см. пример ниже) размером N x N элементов
#  (N определяется по входным данным). Эта таблица содержит нули, но кое-где - единицы. С помощью функции с именем
#  verify, на вход которой передается двумерный список чисел, необходимо проверить, являются ли единицы изолированными
#  друг от друга, то есть, вокруг каждой единицы должны быть нули.
# Рекомендуется следующий алгоритм. В функции verify производить перебор двумерного списка. Для каждого
# элемента (списка) со значением 1 вызывать еще одну вспомогательную функцию is_isolate для проверки изолированности
# единицы. То есть, функция is_isolate должна возвращать True, если единица изолирована и False - в противном случае.
# Как только встречается не изолированная единица, функция verify должна возвращать False. Если успешно доходим
# (по элементам списка) до конца, то возвращается значение True.
# Функцию выполнять не нужно, только определить.
# P. S. При реализации функции is_isolate не следует прописывать восемь операторов if. Подумайте, как это можно
# сделать красивее (с точки зрения реализации алгоритма).
#--- ПРОПУСК ---

# . (Для закрепления предыдущего материала).
# Объявите функцию с именем str_min, которая сравнивает две переданные строки и возвращает минимальную из них
# (то есть, выполняется лексикографическое сравнение строк). Затем, используя функциональный подход к программированию
# (то есть, более сложные функции реализуются путем вызова более простых), реализовать еще две аналогичные функции:
# - с именем str_min3 для поиска минимальной строки из трех переданных строк;
# - с именем str_min4 для поиска минимальной строки из четырех переданных строк.
# Выполнять функции не нужно, только записать.

# def str_min(a, b):
#     return min(a, b)
#
#
# def str_min3(a, b, c):
#     return str_min(c, str_min(b, a))
#
#
# def str_min4(a, b, c, d):
#     return str_min(a, str_min3(b, c, d))
#
# a = "q"
# b = "qw"
# c = "qwe"
# d = "qwer"

# res1 = str_min(a,b)
# res2 = str_min3(a,b,c)
# res3 = str_min4(a,b,c,d)
# print(res1, res2, res3, end='\n')